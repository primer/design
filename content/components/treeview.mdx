---
title: Tree view
---

<Box sx={{fontSize: 3}} class="lead" as="p">
    A tree view is a hierarchical list of items. Items may have a parent-child relationship where children can be toggled into view by expanding or collapsing their parent item.
</Box>

## Anatomy

!üèû[Labeled diagram of a tree view]()
1. Parent node: A node that hides or shows child nodes by expanding or collapsing
2. End node: A node with no children
3. Nesting level indicator lines: Each line represents a level of nesting depth
4. Chevron: Toggles a parent node expanded or collapsed and indicates state
5. Leading visual (optional): A visual cue for additional context
6. Node label: A succinct title for whatever entity the node represents
7. Trailing visual (optional): Same as a leading visual, but at the end

## Content

### Node label

Node labels should be a succinct title for whatever entity the node represents. For example: a file name.

By default, labels are truncated to a single line. However, node labels may be wrapped to multiple lines in cases where a user must always be able to read the entire label.

When a node's text is truncated, it should still be accessible to users via a browser-native tooltip.

!üèû[Single line text truncation]()
!üèû[Multiple lines of text]()


### Leading and trailing visuals

Leading and trailing visuals may be used as visual cues that communicate more information about a node.

If the leading or trailing visual contains useful information, make sure it has a screen-reader accessible text label.

Either all nodes should have leading visuals, or no nodes should have leading visuals.

DO: Have a tree where all nodes are text-only or all nodes have leading visuals
- !üèû[Tree view with all leading visuals OR a tree view with no leading visuals]()
DON'T: Have a tree where only some nodes have leading visuals
- !üèû[Tree view with mixed leading visual treatment]()

## Node interactions

Keyboard users can expand or collapse nodes without activating them by using the left and right arrow keys.

To give cursor users an equivalent experience, there are two click areas:
- clicking the chevron only expands or collapses the node
- clicking anywhere else will activate the node

If the node cannot be activated, clicking anywhere on the node will expand it.

!üèû[Hovering a node that can be activated - show chevron hover and link hover]()
Two click areas - toggle expanded or activate link.

!üèû[Hovering a node that cannot be activated]()
One click area - toggle expanded.

Nodes may not contain any other interactive elements besides the chevron. Activating a node can only perform one action. For example, following a link.

DO: Limit nodes to a single action
- !üèû[Node that is a link]()
DON'T: Put other interactive elements in a node
- !üèû[Node with a button]()

We have investigated the feasibility of supporting a context menu for each node, and that could be something we support in the future if we find we need it.

### States

!üèû[Grid of node states]()

Tree view nodes have different visual treatments to indicate their state and hint what kind of user input they're ready to receive. These styles are inherited from 

## Usage

### Tree views are only for hierarchical lists
A tree view solves a very specific problem. It's not a multi-purpose tool like an [action list](/action-list).

Before reaching for a tree view, first make sure that:
- the items in the tree view represent a list
- the list items are likely to have a parent-child relationship with more than 1 level of nesting
- the expand and collapse behavior aids in navigation instead of just making it more complex

Some good candidates for a tree view are:
- navigating the file structure of a repo
- navigating a codebase's symbols (types, constants, functions, etc) organized by their scope hierarchy

A tree view would not be appropriate for:
- global sidebar navigation
- an FAQ that collapses answers under question headings
- any data that is only likely to have a single level of nesting

DO: Use a tree view for a list
- !üèû[Tree view as file browser]()
DON'T: Use a tree view for expanding and collapsing sections of content
- !üèû[Tree view as code scope expanding and collapsing]()

### Expanding and collapsing nodes

A tree view can be a frustrating pattern if it forces users to spend a lot of time expanding and collapsing nodes to find what they're looking for.

#### Expand parent nodes of an active child
When a node is active, all of it's parent nodes should be expanded.

!üèû[Activated deeply nested node with parents expanded]()

If it's likely that a user will want to interact with all or most of the nodes in the tree, render the tree with all parent nodes expanded to start.

#### Preserve expanded state when parent node is collapsed

If a user expands nested nodes and then collapses a parent node high up in the hierarchy, it could be frustrating to have to re-expand the nodes that were already opened.

!üé•[Expand nested nodes, then collapse high parent node, then expand high parent node to see that they're still expanded]()

#### Optionally combine parent nodes

If no end nodes are in the ancestry and the parent nodes cannot be activated, you may combine parent nodes into a single parent node to reduce the levels of nesting. Less levels of nesting make for a more compact tree and less nodes for the user to expand to get to a node that can be activated.

!üèû[ASCII file tree => file tree with combined parent nodes]()

### Asynchronously loading child nodes

#### Show placeholder nodes (preferred)

When we know the number of loading child nodes, show "skeleton" nodes until the nodes finish loading. This reassures the user that their request is in progress while providing a light preview of what's loading.

!üèû[Skeleton child nodes]()

#### General loading indicator (fallback)

When we don't know the number of loading child nodes, just show a generic loading indicator.

!üèû[Generic loading indicator]()

#### Handling loading errors

Inform users why the data cannot be retrieved and give them a path to resolve it. The error message should behave like a tree node: the entire row is clickable, not just the call-to-action. The call-to-action appears clickable to give a visual cue that the user can interact with the message.

If we don't have enough information to write a useful error message, it's ok to write something generic.

!üèû[Authentication issue error message that is hovered]()

## Composition

!üèû[Wireframe of sidebar + main content area]()

A common pattern is to render a tree view in a split page layout where the tree view is in the left pane, and a view for the selected file is rendered in the main content area.

<!-- However, a tree view does not have to be rendered as a split page layout. It can also be used on it's own to display a hierarchical list.

However, a tree view can also be rendered without a main content area. -->

!üèû[Wireframe of a tree view that replaces itself with the main content]()
However, a tree view can also be rendered on it's own. 

### Examples

!üèû[Tree view as file explorer]()
A tree view being rendered in a split page layout.

!üèû[Tree view as code symbol browsing]()
A tree view that replaces itself with the content of the activated node.

## Layout

### Provide sufficient vertical space

Be considerate of the amount of vertical space a tree view can take up when all of it's nodes are expanded.

DO: Render a tree view in an area with enough vertical space to comfortably look through the list, and doesn't
- !üèû[Tree view as a sidebar]()
DON'T: Render a tree view in an area that pushes down other content or forces users to scroll through small segments
- !üèû[Tree view in a short dialog OR in a sidebar with other content]()

## Nesting

Nodes are visually nested using whitespace and alignment.

### Align leading icons

Icons at the same level are center-aligned. The chevron should not break the alignment: parent nodes and child nodes keep their leading visuals aligned.

!üèû[Nodes w/ alignment guide lines overlaid icons]()

### Indentation

Each level of nesting increases the indentation spacing by the same amount.

!üèû[Nodes w/ indentation spacer indicators]()

### Nesting level indicator lines

In devices with :hover support, the nesting indicator lines fade in when the user mouses over the entire component, or when there's focus inside the component. This makes sure the component remains simple when not in use.

On devices without hover, the nesting indicator lines appear at all times.

!üèû[Tree view with a hover cursor]()
!üèû[Tree view on a fake mobile device]()

### Handling deeply nested nodes

Navigating through deeply nested nodes can be cumbersome and visually clunky. If accessing nodes deeper than 10 levels deep is a common interaction for your use-case, reconsider whether a tree view is the best pattern.

Tree views are designed to be horizontally compact in order to support many levels of nesting and long node labels. This makes content truncation and horizontal overflow less likely to occur for deeply nested nodes, but infinite nesting makes those cases impossible to prevent entirely.

There are some strategies to avoid a tree view that horizontally overflows it's container:
- Allow the tree view's container to be manually resized
- Once a certain depth is reached, start the tree view from a deeper parent node and provide a way to navigate back up the tree
- Remove leading and trailing visuals

If a tree view is truly the best pattern for your use case and none of the suggested strategies prevent horizontal overflow, opt for horizontal scrolling as a last resort instead of hiding overflowing content.

## Accessibility

### Keyboard navigation

| Key(s)                                   | Description                                                                                                                                                                                                                                                                                                                                      |
| ---------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| <kbd>Enter</kbd>                         | Performs the default action (e.g. onclick event) for the focused node which is to activate the link.                                                                                                                                                                                                                                             |
| <kbd>Tab</kbd>                           | Moves focus outside of the tree view to the next focusable node.                                                                                                                                                                                                                                                                                 |
| <kbd>ArrowDown</kbd>                     | <ul><li>Moves focus to the next node that is focusable without opening or closing a node.</li> <li>If focus is on the last node, does nothing.</li></ul>                                                                                                                                                                                         |
| <kbd>ArrowUp</kbd>                       | <ul><li>Moves focus to the previous node that is focusable without opening or closing a node.</li><li>If focus is on the first node, does nothing.</li></ul>                                                                                                                                                                                     |
| <kbd>ArrowRight</kbd>                    | <ul><li>When focus is on a closed node, opens the node; focus does not move.</li><li>When focus is on a open node, moves focus to the first child node.</li><li>When focus is on an end node, does nothing.</li></ul>                                                                                                                            |
| <kbd>ArrowLeft</kbd>                     | <ul><li>When focus is on an open node, closes the node.</li><li>When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.</li><li>When focus is on a root node that is also either an end node or a closed node, does nothing.</li></ul>                                                   |
| <kbd>Home</kbd>                          | Moves focus to first node without opening or closing a node.                                                                                                                                                                                                                                                                                     |
| <kbd>End</kbd>                           | Moves focus to the last node that can be focused without expanding any nodes that are closed.                                                                                                                                                                                                                                                    |
| <kbd>a-z, A-Z</kbd>, all printable chars | <ul><li>Focus moves to the next node with a name that starts with the typed character.</li><li>Search wraps to first node if a matching name is not found among the nodes that follow the focused node.</li><li>Search ignores nodes that are descendants of closed nodes.</li><li>Focus should not move if no nodes match the search.</li></ul> |
| <kbd>Shift</kbd>+<kbd>8</kbd> (`*`)      | <ul><li>Expands all closed sibling nodes that are at the same level as the focused node.</li><li>Focus does not move.</li></ul>                                                                                                                                                                                                                  |

#### Typeahead behavior

!üé•[Typing single character, then quickly typing multiple characters]()

Focus moves to the next node with a name that starts with the typed character(s). Wait for 300ms from the last key press to stop searching.

Typeahead behavior is case insensitive, and any printable character can be used, not just alphanumeric characters. The exception is the `‚Äú*‚Äù` character, which is used to expand all nodes.

The `Space` key is ignored because it's being reserved for toggling a tree view node's checkbox. Nodes with checkboxes are not supported in the first iteration of TreeView, but they may in the future.

### Focus behavior

!üé•[Focus first tree view node, activate a node and move focus into main content area, return focus back to the last focused tree view node]()

#### Focus in

If I'm moving focus into the TreeView for the first time, focus on the first node.

If I'm moving focus back into the TreeView after I've already interacted with it, focus the previously focused TreeView node.

#### Focus out

If activating a node causes new content to appear without a page refresh, focus should be moved to the new content. By default, focus should be moved to the first focusable control within the main content region. We should avoid skipping any content so that the user can easily go back to the TreeView if they activate a node by accident.

If the first focusable element would cause a confusing experience for folks who listen to content using a screen reader, then an alternate element may be defined

### Minimum click target area for the chevron

!üèû[Node with size annotations]()

The chevron has a generous click area to make it an easier target to hit, but it's kept compact to preserve horizontal space in deeply nested nodes.

When we detect that the user is on a device with a coarse pointer, the click target is enlarged.
